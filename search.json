[
  {
    "objectID": "posts/singleton-class/index.html",
    "href": "posts/singleton-class/index.html",
    "title": "O mistério do objeto de Ruby escondido Singleton Class",
    "section": "",
    "text": "Oi, espero que esteja pronto, porque agora iremos tentar entender o que é esse objeto “escondido” por todos os lugares quando programamos em Ruby.\nSe você é um programador curioso, já sabe que Ruby é uma linguagem que utiliza o paradigma de Orientação à Objetos, mais que isso, em Ruby tudo é objeto, tudo mesmo. Quando definimos uma classe House, por exemplo, essa classe também é um objeto, uma instância de Class, podemos perceber isso com o trecho de código abaixo, onde chamamos o método .class que retorna a classe de um objeto.\nclass House; end\n\n# House é uma instância da classe `Class`\nHouse.class  # =&gt; Class\nIsso pode ser diferente das coisas que você já viu antes e funciona de forma diferente de como eu acreditava, então começei a me perguntar como essa característica da linguagem me impactava como programador? Eu não tinha uma resposta muito boa e procurei entender mais sobre esse comportamento, até que encontrei a chamada Singleton Class (também encontrei referências que chamam Eigenclass, Classe anônima e Object-Specific Class), a responsável por termos em Ruby os chamados métodos de classe, como o desse trecho abaixo.\nclass House\n    def self.open\n        puts \"...Opened\"\n    end\nend\n\nHouse.open  # =&gt; ...Opened\nAcredito que não há nada no código acima que seja diferente do que estamos acostumados escrever como programador Ruby. Singleton Classes nos permitem adicionar métodos em objetos pré-definidos que só afetarão o objeto que define este método, como no trecho abaixo.\nclass House\n    def lawn_situation\n        puts \"...this is perfect\"\n    end\nend\n\nmy_home = House.new\nneighbors_house = House.new\n\ndef my_home.lawn_situation\n    puts \"...could be better\"\nend\n\nneighbors_house.lawn_situation  # =&gt; ...this is perfect\nmy_home.lawn_situation  # =&gt; ...could be better\nIsso também explica como criamos o método de classe self.open do trecho anterior, pois como a classe House é um objeto da classe Class, então também utilizamos essa sintáxe (self.open) para adicionar um novo método nesse objeto pré-definido.\nEntendi então que as sintaxes def self.open e def my_home.lawn_situation são responsáveis por acessar a Singleton Class desses objetos adicionandos estes métodos nelas e não diretamente nas suas classes, permitindo que estes novos métodos afetem apenas os seus respectivos objetos.\nAcredito que nesse momento conseguimos compreender o que é esse objeto chamado Singleton Class e como utilizamos, mas ainda não discutimos sobre como ele nos impacta na vida real, pois faremos isso agora. Em conversa com alguns colegas, foi citado que um possível uso para essa característica da linguagem seria sobreescrever métodos de objetos para auxiliar alguns testes. No exemplo a seguir, utilizamos a Singleton Class para sobreescrever um método com o objetivo de auxiliar o teste de um trecho código.\n# Definindo a classe House\nclass House\n    def self.close\n        self.close_back_door\n        self.close_windows\n        self.close_principal_door\n        nil\n    end\n\n    def self.close_back_door = puts \"...Closed Back Door\"\n    def self.close_windows = puts \"...Closed Windows\"\n    def self.close_principal_door = puts \"...Closed Principal Door\"\nend\n\n# Testando a classe House\ncontext \"Error to close the house\" do\n    def House.close_principal_door\n        raise EspecificException, \"Error to close the principal door\"\n    end\n\n    expect(House.close).to raise_error(EspecificException)\nend\nParticularmente, saber dessa característica de Ruby, me fez entender mais claramente um bug que criei ao desenvolver um comportamento, vou tentar apenas ilustrar o problema ocorrido em um contexto mais simples no trecho abaixo.\nclass Book\n    def self.gift_a_friend(friend, book)\n        @friend = friend\n        @book = book\n\n        return send_now(@book) unless friend_has_this_book?\n\n        puts \"#{@friend.name} já possui o livro '#{@book}'\"\n    end\n\n    private\n\n    def self.friend_has_this_book?\n        puts \"Verificando se #{@friend.name} já possui o livro '#{@book}'\"\n        @friend_has_this_book ||= @friend.books.include?(@book)\n    end\n\n    def self.send_now(book)\n        puts \"Enviando o livro '#{book}' para #{@friend.name}!\"\n        @friend.add_book(book)\n    end\nend\n\nclass Friend\n    attr_reader :name, :books\n\n    def initialize(name, books = [])\n        @name = name\n        @books = books\n    end\n\n    def add_book(book)\n        @books &lt;&lt; book\n    end\nend\n\njoao = Friend.new('João')\nguilherme = Friend.new('Guilherme')\n\nBook.gift_a_friend(joao, 'Lord of the Rings')\n# Verificando se João já possui o livro 'Lord of the Rings'\n# Enviando o livro 'Lord of the Rings' para João!\n\nBook.gift_a_friend(joao, 'Lord of the Rings')\n# Verificando se João já possui o livro 'Lord of the Rings'\n# João já possui o livro 'Lord of the Rings'\n\nBook.gift_a_friend(guilherme, 'Lord of the Rings')\n# Verificando se Guilherme já possui o livro 'Lord of the Rings'\n# Guilherme já possui o livro 'Lord of the Rings'\n\nguilherme\n# =&gt; #&lt;Friend:0x000079bd4d8e6d20 @books=[], @name=\"Guilherme\"&gt;\n\n# WTF? Guilherme não possui o livro 'Lord of the Rings'\nO problema é que, na segunda vez em que o método .friend_has_this_book? for chamado, ele não vai executar @friend.books.include?(@book) pois o valor @friend_has_this_book já foi preenchido, pois a Singleton Class é criada apenas uma única vez (por isso o nome Singleton), as chamadas seguintes apenas acessarão a Singleton Class já existente mantendo seu estado.\nEu gostaria de ter entendido bem antes esse conceito da linguagem, mas é um ótimo ponto de partida pra quem quer conhecer mais profundamente a linguagem Ruby e suas características, com certeza esses entendimentos irão evitar a os erros e ajudá-lo na análise dos problemas que você enfrentará como programador. Espero que tenha gostado, até a próxima.\nAlgumas fontes que eu utilizei para entender um pouco mais sobre esse assunto: - Ruby Singleton Class - Explaining Ruby’s Singleton Class (Eigenclass) to confused beginners"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Developer Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nThe mistery of the hidden Ruby object called Singleton Class\n\n\n\n\n\n\ncode\n\n\nruby\n\n\n\n\n\n\n\n\n\nAug 12, 2024\n\n\nJ. Moura\n\n\n\n\n\n\n\n\n\n\n\n\nO mistério do objeto de Ruby escondido Singleton Class\n\n\n\n\n\n\ncode\n\n\nruby\n\n\n\n\n\n\n\n\n\nAug 12, 2024\n\n\nJoão Moura\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Blog criado para documentar meus aprendizados e conhecimentos em desenvolvimento de software."
  },
  {
    "objectID": "about.html#meu-stack",
    "href": "about.html#meu-stack",
    "title": "About",
    "section": "Meu Stack",
    "text": "Meu Stack\n\nRuby\nRails\nPostgreSQL\nDocker\nGit"
  },
  {
    "objectID": "posts/singleton-class-en/index.html",
    "href": "posts/singleton-class-en/index.html",
    "title": "The mistery of the hidden Ruby object called Singleton Class",
    "section": "",
    "text": "Hi, I expect are you ready, now we will try to understand what is this “hidden” object in all places when we code in ruby.\nIf you are a curious programmer, you know that Ruby is a Object Oriented programming language, and beyond, everything is an object in ruby, everything. When we define a House class, for exemple, this class is also an object, a Class instance. We can see this in the code snippet below, where we call the .class method returning the class name of this object.\nclass House; end\n\n# House is an intance of `Class`\nHouse.class  # =&gt; Class\nThis can be different you have seen before and works different from how I thought, so I started to ask how this language feature impacted me as a programmer? I didn’t have a good answer and I searched more about this behaviour, until I found the Singleton Class (I also found references calling Eigenclass, Anonymous Class and Object-Specific Class), the responsible for the ruby class methods, like the code snippet below.\nclass House\n    def self.open\n        puts \"...Opened\"\n    end\nend\n\nHouse.open  # =&gt; ...Opened\nI believe there is nothing in this code different of we use to write ruby code everyday. Singleton Classes allow us to add methods to pre-defined objects that only affect the object that defines this method, like the code snippet below.\nclass House\n    def lawn_situation\n        puts \"...this is perfect\"\n    end\nend\n\nmy_home = House.new\nneighbors_house = House.new\n\ndef my_home.lawn_situation\n    puts \"...could be better\"\nend\n\nneighbors_house.lawn_situation  # =&gt; ...this is perfect\nmy_home.lawn_situation  # =&gt; ...could be better\nThis also explain how we create the self.open method in the previous code, since the House class is an object of the Class class, so we also use this syntax (self.open) to add a new method to this pre-defined object.\nNow, I understand that the syntaxes def self.open and def my_home.lawn_situation are responsible for accessing the Singleton Class of these objects to add the methods and not directly to their classes, allowing these new methods to only affect their respective objects.\nI think now we can understand what is this object called Singleton Class and how we use it, but we haven’t discussed how it impacts our real life, so we will do it now. In a conversation with some friends, it was mentioned a use case to this feature, we can to override object methods to help us to create some specs. Below, we used the Singleton Class to override a method to help us to test a code behaviour.\n# Defining House class\nclass House\n    def self.close\n        self.close_back_door\n        self.close_windows\n        self.close_principal_door\n        nil\n    end\n\n    def self.close_back_door = puts \"...Closed Back Door\"\n    def self.close_windows = puts \"...Closed Windows\"\n    def self.close_principal_door = puts \"...Closed Principal Door\"\nend\n\n# Testing .close method\ncontext \"Error to close the house\" do\n    def House.close_principal_door\n        raise EspecificException, \"Error to close the principal door\"\n    end\n\n    expect(House.close).to raise_error(EspecificException)\nend\nParticularly, knowing this ruby feature, made me understand clearly about a bug I created when I was developing a new system feature, I will try to illustrate the problem in a simpler context.\nclass Book\n    def self.gift_a_friend(friend, book)\n        @friend = friend\n        @book = book\n\n        return send_now(@book) unless friend_has_this_book?\n\n        puts \"#{@friend.name} already has the book '#{@book}'\"\n    end\n\n    private\n\n    def self.friend_has_this_book?\n        puts \"Verifying if #{@friend.name} already has the book '#{@book}'\"\n        @friend_has_this_book ||= @friend.books.include?(@book)\n    end\n\n    def self.send_now(book)\n        puts \"Sending the book '#{book}' to #{@friend.name}!\"\n        @friend.add_book(book)\n    end\nend\n\nclass Friend\n    attr_reader :name, :books\n\n    def initialize(name, books = [])\n        @name = name\n        @books = books\n    end\n\n    def add_book(book)\n        @books &lt;&lt; book\n    end\nend\n\njoao = Friend.new('J. Moura')\nguilherme = Friend.new('Guilherme')\n\nBook.gift_a_friend(joao, 'Lord of the Rings')\n# Verifying if J. Moura already has the book 'Lord of the Rings'\n# Sending the book 'Lord of the Rings' to J. Moura!\n\nBook.gift_a_friend(joao, 'Lord of the Rings')\n# Verifying if J. Moura already has the book 'Lord of the Rings'\n# J. Moura already has the book 'Lord of the Rings'\n\nBook.gift_a_friend(guilherme, 'Lord of the Rings')\n# Verifying if Guilherme already has the book 'Lord of the Rings'\n# Guilherme already has the book 'Lord of the Rings'\n\nguilherme\n# =&gt; #&lt;Friend:0x000079bd4d8e6d20 @books=[], @name=\"Guilherme\"&gt;\n\n# WTF? Guilherme has not the book 'Lord of the Rings'\nThe problem is in the second time when the .friend_has_this_book? method is called, it will not execute @friend.books.include?(@book) because the @friend_has_this_book instance variable value has already been set. The Singleton Class is created only once (this explains the name Singleton), the following calls will only access the existing Singleton Class keeping its state.\nI would like to understood it before, but it is a good starting for who want to know deeper about the ruby language and its features, these knowledge will avoid the errors and help us to analyze the problems you will face as a programmer. I hope you enjoyed, see you.\nSome sources I used to understand about this subject:\n\nRuby Singleton Class\nExplaining Ruby’s Singleton Class (Eigenclass) to confused beginners"
  }
]