{"title":"O mistério do objeto de Ruby escondido Singleton Class","markdown":{"yaml":{"title":"O mistério do objeto de Ruby escondido Singleton Class","author":"João Moura","date":"2024-08-12","categories":["code","ruby"],"image":"ruby_cave.jpeg"},"headingText":"House é uma instância da classe `Class`","containsRefs":false,"markdown":"\n\nOi, espero que esteja pronto, porque agora iremos tentar entender o que é esse objeto \"escondido\" por todos os lugares quando programamos em Ruby.\n\nSe você é um programador curioso, já sabe que Ruby é uma linguagem que utiliza o paradigma de Orientação à Objetos, mais que isso, em Ruby tudo é objeto, tudo mesmo. Quando definimos uma classe `House`, por exemplo, essa classe também é um objeto, uma instância de `Class`, podemos perceber isso com o trecho de código abaixo, onde chamamos o método `.class` que retorna a classe de um objeto.\n\n```ruby\nclass House; end\n\nHouse.class  # => Class\n```\n\nIsso pode ser diferente das coisas que você já viu antes e funciona de forma diferente de como eu acreditava, mas como essa característica da linguagem me impactava como programador? Eu não sabia, então procurei entender mais sobre esse comportamento, até que encontrei a chamada Singleton Class, também encontrei referências que chamam de Eigenclass ou Classe anônima. Independente de como chamamos, essa classe \"escondida\" é responsável por termos em Ruby os chamados métodos de classe, como o desse trecho abaixo.\n\n```ruby\nclass House\n    def self.open\n        puts \"...Opened\"\n    end\nend\n\nHouse.open  # => ...Opened\n```\n\nAcredito que não há nada diferente nesse código do que estamos acostumados escrever como programador Ruby, mas o que novidade para mim é saber que a sintáxe `def self.open` é a responsável por acessar a Singleton Class da classe `House`. Pode ser que começamos a ficar um pouco confusos. Resumindo, quando criamos um objeto e utilizamos essa sintáxe `self`, criamos uma Singleton Class, que é uma classe anônima ligada apenas ao objeto que a criou.\n\nQuando inserimos o trecho `def self.open`, na verdade estamos criando uma Singleton class ligada à classe `House` (que é uma instância de Class, ou seja, também é um objeto) e definindo o método `open` nela, quando chamamos `House.open`, estamos chamando o método da Singleton Class que foi criada.\nTalvez fique mais fácil de entender se você imaginar que, métodos de classe não existem, na verdade, eles são a sintáxe que utilizamos para acessar os métodos da Singleton Class de um objeto.\nFica mais intuitivo entender o nome dado quando sabemos que, quando executamos `House.open` pela segunda vez, não é criada uma nova Singleton Class, apenas é executado o método definido na instância criada anteriormente, seguindo o Singleton Pattern.\n\n```ruby\nclass House\n    def self.open\n        puts \"...Opened\"\n    end\nend\n\n# Não cria uma nova Singleton Class, apenas adiciona um novo método na instância existente\ndef House.close\n    puts \"...Closed\"\nend\n\nHouse.open   # => ...Opened\nHouse.close  # => ...Closed\n```\n\nAcredito que nesse momento conseguimos compreender o que é esse objeto chamado Singleton Class e como utilizamos, mas ainda não discutimos sobre como ele nos impacta na vida real, pois faremos isso agora.\nEm conversa com alguns colegas, foi citado que um possível uso para essa característica da linguagem seria sobreescrever métodos de objetos para auxiliar alguns testes. No exemplo a seguir, utilizamos a Singleton Class de um objeto para sobreescrever um método para auxiliar o teste de um trecho código.\n\n```ruby\ncontext \"Error to close the house\" do\n    # Método chamado dentro de self.close\n    def House.close_principal_door\n        raise EspecificException, \"Error to close the principal door\"\n    end\n\n    expect(House.close).to raise_error(EspecificException)\nend\n```\n\nParticularmente, saber dessa característica de Ruby, me fez entender mais claramente um bug que criei ao desenvolver um comportamento, vou tentar apenas ilustrar o problema ocorrido em um contexto mais simples no trecho abaixo.\n\n```ruby\nclass Book\n    def self.gift_a_friend(friend, book)\n        @fried = friend\n        @book = book\n\n        send_now(book) unless friend_has_this_book?\n    end\n\n    private\n\n    def self.friend_has_this_book?\n        @friend_has_this_book ||= @friend.books.include? @book\n    end\nend\n\nBook.gift_a_friend(friend1, book)  # => Comportamento correto\nBook.gift_a_friend(friend2, book)  # => Comportamento errado\n```\n\nO problema é que, na segunda vez em que o método `.friend_has_this_book` for chamado, ele não vai executar `@friend.books.include? @book` pois o valor `@friend_has_this_book` já foi preenchido na primeira vez em que o código foi executado.\n\nEu gostaria de ter entendido bem antes esse conceito da linguagem, mas é um ótimo ponto de partida pra quem quer conhecer mais profundamente a linguagem Ruby e suas características, com certeza esses entendimentos irão evitar a os erros e ajudá-lo na análise dos problemas que você enfrentará como programador.\nEspero que tenha gostado, até a próxima.\n","srcMarkdownNoYaml":"\n\nOi, espero que esteja pronto, porque agora iremos tentar entender o que é esse objeto \"escondido\" por todos os lugares quando programamos em Ruby.\n\nSe você é um programador curioso, já sabe que Ruby é uma linguagem que utiliza o paradigma de Orientação à Objetos, mais que isso, em Ruby tudo é objeto, tudo mesmo. Quando definimos uma classe `House`, por exemplo, essa classe também é um objeto, uma instância de `Class`, podemos perceber isso com o trecho de código abaixo, onde chamamos o método `.class` que retorna a classe de um objeto.\n\n```ruby\nclass House; end\n\n# House é uma instância da classe `Class`\nHouse.class  # => Class\n```\n\nIsso pode ser diferente das coisas que você já viu antes e funciona de forma diferente de como eu acreditava, mas como essa característica da linguagem me impactava como programador? Eu não sabia, então procurei entender mais sobre esse comportamento, até que encontrei a chamada Singleton Class, também encontrei referências que chamam de Eigenclass ou Classe anônima. Independente de como chamamos, essa classe \"escondida\" é responsável por termos em Ruby os chamados métodos de classe, como o desse trecho abaixo.\n\n```ruby\nclass House\n    def self.open\n        puts \"...Opened\"\n    end\nend\n\nHouse.open  # => ...Opened\n```\n\nAcredito que não há nada diferente nesse código do que estamos acostumados escrever como programador Ruby, mas o que novidade para mim é saber que a sintáxe `def self.open` é a responsável por acessar a Singleton Class da classe `House`. Pode ser que começamos a ficar um pouco confusos. Resumindo, quando criamos um objeto e utilizamos essa sintáxe `self`, criamos uma Singleton Class, que é uma classe anônima ligada apenas ao objeto que a criou.\n\nQuando inserimos o trecho `def self.open`, na verdade estamos criando uma Singleton class ligada à classe `House` (que é uma instância de Class, ou seja, também é um objeto) e definindo o método `open` nela, quando chamamos `House.open`, estamos chamando o método da Singleton Class que foi criada.\nTalvez fique mais fácil de entender se você imaginar que, métodos de classe não existem, na verdade, eles são a sintáxe que utilizamos para acessar os métodos da Singleton Class de um objeto.\nFica mais intuitivo entender o nome dado quando sabemos que, quando executamos `House.open` pela segunda vez, não é criada uma nova Singleton Class, apenas é executado o método definido na instância criada anteriormente, seguindo o Singleton Pattern.\n\n```ruby\nclass House\n    def self.open\n        puts \"...Opened\"\n    end\nend\n\n# Não cria uma nova Singleton Class, apenas adiciona um novo método na instância existente\ndef House.close\n    puts \"...Closed\"\nend\n\nHouse.open   # => ...Opened\nHouse.close  # => ...Closed\n```\n\nAcredito que nesse momento conseguimos compreender o que é esse objeto chamado Singleton Class e como utilizamos, mas ainda não discutimos sobre como ele nos impacta na vida real, pois faremos isso agora.\nEm conversa com alguns colegas, foi citado que um possível uso para essa característica da linguagem seria sobreescrever métodos de objetos para auxiliar alguns testes. No exemplo a seguir, utilizamos a Singleton Class de um objeto para sobreescrever um método para auxiliar o teste de um trecho código.\n\n```ruby\ncontext \"Error to close the house\" do\n    # Método chamado dentro de self.close\n    def House.close_principal_door\n        raise EspecificException, \"Error to close the principal door\"\n    end\n\n    expect(House.close).to raise_error(EspecificException)\nend\n```\n\nParticularmente, saber dessa característica de Ruby, me fez entender mais claramente um bug que criei ao desenvolver um comportamento, vou tentar apenas ilustrar o problema ocorrido em um contexto mais simples no trecho abaixo.\n\n```ruby\nclass Book\n    def self.gift_a_friend(friend, book)\n        @fried = friend\n        @book = book\n\n        send_now(book) unless friend_has_this_book?\n    end\n\n    private\n\n    def self.friend_has_this_book?\n        @friend_has_this_book ||= @friend.books.include? @book\n    end\nend\n\nBook.gift_a_friend(friend1, book)  # => Comportamento correto\nBook.gift_a_friend(friend2, book)  # => Comportamento errado\n```\n\nO problema é que, na segunda vez em que o método `.friend_has_this_book` for chamado, ele não vai executar `@friend.books.include? @book` pois o valor `@friend_has_this_book` já foi preenchido na primeira vez em que o código foi executado.\n\nEu gostaria de ter entendido bem antes esse conceito da linguagem, mas é um ótimo ponto de partida pra quem quer conhecer mais profundamente a linguagem Ruby e suas características, com certeza esses entendimentos irão evitar a os erros e ajudá-lo na análise dos problemas que você enfrentará como programador.\nEspero que tenha gostado, até a próxima.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","theme":"cosmo","title-block-banner":true,"title":"O mistério do objeto de Ruby escondido Singleton Class","author":"João Moura","date":"2024-08-12","categories":["code","ruby"],"image":"ruby_cave.jpeg"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}